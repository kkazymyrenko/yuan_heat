# -*- coding: utf-8 -*-
"""3D Heat Gradients Auto-tunes Penalty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rewhPU4fQr0oqdkJpZtlowO-F5SeNGyb
"""

#!pip install numpy scipy noisyopt matplotlib qiskit==1.1.1 --no-cache-dir --force-reinstall --quiet
#!pip install nlopt
#!pip install pickle5
#!pip install cma
#!pip install pylatexenc
#!pip install pandas
#!pip install plotly

import numpy as np
import matplotlib.pyplot as plt
import scipy as sc
import time
import qiskit as qi
from qiskit.circuit.library import RealAmplitudes, NLocal, RXGate, RYGate, CRZGate, CZGate, CXGate
from qiskit.circuit import Parameter
from qiskit.quantum_info import SparsePauliOp, Operator, Statevector
from scipy.sparse import csr_matrix
import plotly.graph_objects as go
import plotly.io as pio

pio.renderers.default = "browser"
normalize = True

def idx(i, j, l, N):
    return i + j*N + l*N*N

def laplace_3d_fdm(N, h, kappa=1.0):
    size = N**3
    data, rows, cols = [], [], []
    for ix in range(N):
        for iy in range(N):
            for iz in range(N):
                row = idx(ix, iy, iz, N)
                data.append(-6)
                rows.append(row)
                cols.append(row)
                for (dx, dy, dz) in [(-1,0,0),(1,0,0),(0,-1,0),(0,1,0),(0,0,-1),(0,0,1)]:
                    jx, jy, jz = ix+dx, iy+dy, iz+dz
                    if 0 <= jx < N and 0 <= jy < N and 0 <= jz < N:
                        col = idx(jx, jy, jz, N)
                        data.append(1)
                        rows.append(row)
                        cols.append(col)
    A = sc.sparse.coo_matrix((data, (rows, cols)), shape=(size, size)).tocsr()
    return -kappa/h**2 * A

# Parameters
N = 8        # Number of grid points along each spatial axis
L = 3.0      # Physical length of each cube side
h = L / (N - 1)  # Distance between adjacent nodes
kappa = 1.0  # Diffusion coefficient or PDE constant
lay = 8      # Circuit depth


A = laplace_3d_fdm(N, h, kappa)
b = np.zeros(N**3)

# Dirichlet Boundary
def apply_dirichlet(A, b, N, face, value):
    A = A.tolil()
    if face == 'x-':
        for l in range(N):
            for j in range(N):
                row = idx(0, j, l, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    elif face == 'x+':
        for l in range(N):
            for j in range(N):
                row = idx(N-1, j, l, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    elif face == 'y-':
        for l in range(N):
            for i in range(N):
                row = idx(i, 0, l, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    elif face == 'y+':
        for l in range(N):
            for i in range(N):
                row = idx(i, N-1, l, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    elif face == 'z-':
        for j in range(N):
            for i in range(N):
                row = idx(i, j, 0, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    elif face == 'z+':
        for j in range(N):
            for i in range(N):
                row = idx(i, j, N-1, N)
                A[row, :] = 0
                A[row, row] = 1
                b[row] = value
    else:
        raise ValueError(f"Invalid face name '{face}'.")
    return A.tocsr(), b

# Set BCs (small Dirichlet values)
# Apply Dirichlet boundary conditions on all six faces of the 3D cube.
A, b = apply_dirichlet(A, b, N, 'x-', 0.3)  # Left face (x = 0): fixed value 0.3
A, b = apply_dirichlet(A, b, N, 'x+', 0.2)  # Right face (x = L): fixed value 0.2
A, b = apply_dirichlet(A, b, N, 'y-', 0.1)  # Front face (y = 0): fixed value 0.1
A, b = apply_dirichlet(A, b, N, 'y+', 0.4)  # Back face (y = L): fixed value 0.4
A, b = apply_dirichlet(A, b, N, 'z-', 0.2)  # Bottom face (z = 0): fixed value 0.2
A, b = apply_dirichlet(A, b, N, 'z+', 0.3)  # Top face (z = L): fixed value 0.3

# Classical Solve
A_sparse = csr_matrix(A)
ucl = sc.sparse.linalg.spsolve(A_sparse, b)
ucl = ucl.real
ucl = ucl / np.linalg.norm(ucl)

H = A.toarray()
n_nodes = N**3
nqb = int(np.log2(n_nodes))
assert 2**nqb == n_nodes, "n_nodes must be a power of 2 for quantum state mapping"
SPOH = SparsePauliOp.from_operator(Operator(H))
frc = b

def norm(x): return x / (np.linalg.norm(x) if normalize else 1)

def MSE(u, v): return np.mean((u - v) ** 2)

def trace_error(u, v):
    u_n = u / np.linalg.norm(u)
    v_n = v / np.linalg.norm(v)
    return np.sqrt(1 - np.dot(u_n, v_n)**2)

# Ansatz (Tested several)
#def ansatz_realamp_linear(nqb, lay):
    #return RealAmplitudes(num_qubits=nqb, entanglement='linear', reps=lay)

#def ansatz_realamp_full(nqb, lay):
    #return RealAmplitudes(num_qubits=nqb, entanglement='full', reps=lay)

def ansatz_rx_ry_linear(nqb, lay):
    theta = Parameter("θ")
    return NLocal(
        num_qubits=nqb,
        rotation_blocks=[RXGate(theta), RYGate(theta)],
        entanglement_blocks=CXGate(),
        entanglement="linear",
        reps=lay
    )

#def ansatz_ry_crz_cz_circ(nqb, lay):
    #theta = Parameter("θ")
    #return NLocal(
        #num_qubits=nqb,
        #rotation_blocks=[RYGate(theta)],
        #entanglement_blocks=[CRZGate(theta), CZGate()],
        #entanglement="circular",
        #reps=lay
    #)

def ansatz_ry_cz_full(nqb, lay):
    theta = Parameter("θ")
    return NLocal(
        num_qubits=nqb,
        rotation_blocks=[RYGate(theta)],
        entanglement_blocks=CZGate(),
        entanglement="full",
        reps=lay
    )

ansatz_list = [
    ("NLocal RX+RY linear", ansatz_rx_ry_linear),
    ("NLocal RY+CZ full", ansatz_ry_cz_full)
]

# Penalty functions
def mse_penalty(par, ucl, una_ans, get_Stt_lazy):
    """
    Calculates the mean squared error (MSE) penalty between the quantum (VQA) solution and the normalized classical solution.

    """
    psi = get_Stt_lazy(par)  # Get the quantum statevector from the current circuit parameters
    psi = psi / np.linalg.norm(psi)  # Normalize the quantum statevector (quantum states are normalized)
    ucl_n = ucl / np.linalg.norm(ucl)   # Normalize the classical reference solution
    return np.mean((psi - ucl_n) ** 2)   # Return the MSE

def grad_mse_penalty(par, ucl, una_ans, get_Stt_lazy):
    """
    Computes the gradient of the MSE penalty with respect to the quantum circuit parameters,
    using a symmetric finite-difference (parameter-shift) method. This is used by the optimizer to update parameters and minimize the penalty term.
    """
    eps = np.pi / 2                          # Finite-difference shift step
    grad = np.zeros_like(par)
    psi_0 = get_Stt_lazy(par) / np.linalg.norm(get_Stt_lazy(par))
    ucl_n = ucl / np.linalg.norm(ucl)
    for i in range(len(par)):
        par_plus = np.array(par)
        par_minus = np.array(par)
        par_plus[i] += eps  # Increment i-th parameter by +eps
        par_minus[i] -= eps  # Decrement i-th parameter by -eps
        psi_plus = get_Stt_lazy(par_plus) / np.linalg.norm(get_Stt_lazy(par_plus))
        psi_minus = get_Stt_lazy(par_minus) / np.linalg.norm(get_Stt_lazy(par_minus))
        # Central difference approximation for derivative of MSE w.r.t parameter i
        grad[i] = (np.mean((psi_plus - ucl_n) ** 2) - np.mean((psi_minus - ucl_n) ** 2)) / (2 * eps)
    return grad



for ansatz_name, ansatz_func in ansatz_list:
    print("="*70)
    print(f"Trying ansatz: {ansatz_name}")
    una_ans = ansatz_func(nqb, lay)
    num_par = una_ans.num_parameters

    def get_Stt_lazy(par):
        ans = una_ans.assign_parameters(parameters=par, inplace=False)
        qc = qi.QuantumCircuit(nqb)
        qc.append(ans, list(range(nqb)))
        state = Statevector(qc)
        return state.data.real

    def cost_func(par, SPOH, f, una_ans):
        psi = get_Stt_lazy(par)
        A = float(np.real(np.dot(f, psi)))
        B = float(np.real(np.dot(psi, SPOH.to_matrix() @ psi)))
        return float(np.real(-0.5 * (A ** 2) / B))

    def shift_rule_grad(par, SPOH, f, una_ans):
        grad = np.zeros_like(par)

        # Compute cost function intermediates at current parameters
        A = float(np.real(np.dot(f, get_Stt_lazy(par))))
        B = float(np.real(np.dot(get_Stt_lazy(par), SPOH.to_matrix() @ get_Stt_lazy(par))))

        for i in range(len(par)):
            par_plus = np.array(par)
            par_minus = np.array(par)
            par_plus[i] += np.pi  # Shift i-th parameter by +pi
            par_minus[i] -= np.pi # -pi

            # Evaluate statevector at shifted parameters
            psi_plus = get_Stt_lazy(par_plus)
            psi_minus = get_Stt_lazy(par_minus)

            A_plus = float(np.real(np.dot(f, psi_plus)))
            A_minus = float(np.real(np.dot(f, psi_minus)))
            B_plus = float(np.real(np.dot(psi_plus, SPOH.to_matrix() @ psi_plus)))
            B_minus = float(np.real(np.dot(psi_minus, SPOH.to_matrix() @ psi_minus)))

            # Parameter-shift derivative (central difference)
            dA = 0.5 * (A_plus - A_minus)
            dB = 0.5 * (B_plus - B_minus)

            grad[i] = -2 * A / B * dA + (A ** 2) / (B ** 2) * dB
        return grad

    def shift_rule_hess(par, SPOH, f, una_ans):
        # Approximates the Hessian of the Rayleigh quotient cost function using the parameter-shift rule and a central finite difference.
        # Only diagonal entries are computed for efficiency.
        # Afterward, ensures the Hessian is positive definite, which is required by Newton-type optimizers.
        hess = np.zeros((len(par), len(par)))
        eps = np.pi
        # Compute diagonal entries of the Hessian
        for i in range(len(par)):
            par_plus = np.array(par)
            par_minus = np.array(par)
            par_plus[i] += eps
            par_minus[i] -= eps
            f_p = float(np.real(cost_func(par_plus, SPOH, f, una_ans)))
            f_0 = float(np.real(cost_func(par,     SPOH, f, una_ans)))
            f_m = float(np.real(cost_func(par_minus, SPOH, f, una_ans)))
            hess[i, i] = (f_p - 2*f_0 + f_m) / (eps ** 2)
        # Force positive definite for Hessian matrix
        def is_pos_def(A):
        # Checks if matrix A is positive definite using Cholesky decomposition.
        # Returns True if PD, otherwise False.
            try:
                np.linalg.cholesky(A)
                return True
            except np.linalg.LinAlgError:
                return False
        reg = 1e-6
        max_reg = 1e-1
        reg_count = 0

        # If Hessian is not positive definite, add a regularization term

        while not is_pos_def(hess):
            hess += reg * np.eye(len(par))
            reg *= 10
            reg_count += 1
            if reg > max_reg:
                print(f"Warning: Could not make Hessian positive definite after {reg_count} attempts.")
                break
        return hess

    # Penalty-augmented functions
    def combined_cost(par, SPOH, frc, una_ans, ucl, lambda_penalty):
        return (
            cost_func(par, SPOH, frc, una_ans)
            + lambda_penalty * mse_penalty(par, ucl, una_ans, get_Stt_lazy)
        )
    def combined_grad(par, SPOH, frc, una_ans, ucl, lambda_penalty):
        return (
            shift_rule_grad(par, SPOH, frc, una_ans)
            + lambda_penalty * grad_mse_penalty(par, ucl, una_ans, get_Stt_lazy)
        )
    def combined_hess(par, SPOH, frc, una_ans, ucl, lambda_penalty):
    # Only diagonal terms, penalty hessian is not implemented
        return shift_rule_hess(par, SPOH, frc, una_ans)

    # Auto-tune lambda_penalty
    # A penalty terms are used to ensure the quantum ansatz not only solves the PDE but also matches the classical solution somewhat closely
    par_random = 2 * np.pi * (np.random.rand(num_par) - 0.5)
    # Compute norm of the physics-based gradient (from Rayleigh quotient cost) and the gradient for the MSE penalty
    grad_phys = np.linalg.norm(shift_rule_grad(par_random, SPOH, frc, una_ans))
    grad_mse = np.linalg.norm(grad_mse_penalty(par_random, ucl, una_ans, get_Stt_lazy))
    lambda_adaptive = grad_phys / (grad_mse + 1e-8) # Auto-tune: Scale penalty
    #lambda_adaptive = 0.01
    # 0.1, 0.05, 0.001
    print(f"Auto-tuned lambda_penalty = {lambda_adaptive:.4e}")

    # Run a couple iterations with L-BFGS-B for warm start
    print("Pre-optimizing with L-BFGS-B for warm start...")
    res_lbfgs = sc.optimize.minimize(
        combined_cost, par_random, args=(SPOH, frc, una_ans, ucl, lambda_adaptive),
        tol=1e-4, method='L-BFGS-B', bounds=[(-2*np.pi,2*np.pi)]*num_par,
        jac=combined_grad, options={'maxiter': 20}
    )
    # Bounds could be (-np.pi,np.pi)
    par_warm = res_lbfgs.x
    print(f"L-BFGS-B pre-optimizer done. Pre-opt cost: {res_lbfgs.fun:.4e}")

    # Newton-CG with positive definite Hessian and penalty
    print("*** Beginning penalty-augmented Newton-CG optimization ***")
    callback_dict = {"iters": 0, "cost_history": []}
    def callback(par):
        callback_dict["iters"] += 1
        c = combined_cost(par, SPOH, frc, una_ans, ucl, lambda_adaptive)
        callback_dict["cost_history"].append(c)
        print(f"[{callback_dict['iters']:3d}] Cost: {c:.4e}")

    start = time.perf_counter()
    res = sc.optimize.minimize(
        combined_cost, par_warm, args=(SPOH, frc, una_ans, ucl, lambda_adaptive),
        tol=1e-4, method='Newton-CG', jac=combined_grad, hess=combined_hess,
        callback=callback, options={'maxiter': 200, 'disp': True}
    ) # maxiter = 100, 300, 500
    end = time.perf_counter()
    exe_time = end - start

    print("Newton-CG Optimization Message:", res.message)
    print("Success:", res.success)
    print("nfev:", res.nfev)
    print(f"Optimization time: {exe_time//60:.0f}m {exe_time%60:.2f}s")
    print("Quantum minimum:", res.fun)

    par_opt = res.x
    xquant = get_Stt_lazy(par_opt)
    xquant = xquant / np.linalg.norm(xquant)

    # Error metrics
    print(f"\n--- ERROR METRICS ({ansatz_name}) ---")
    print("Quantum state norm:", np.linalg.norm(xquant))
    print("Classical state norm:", np.linalg.norm(ucl))
    print(f"MSE error: {MSE(xquant, ucl):.6e}")
    print(f"Trace error: {trace_error(xquant, ucl):.6e}")
    print(f"Quantum minimum cost: {res.fun:.6e}")

    x = np.linspace(0, L, N)
    y = np.linspace(0, L, N)
    z = np.linspace(0, L, N)
    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

    uquant3d = xquant.reshape((N, N, N))
    ucl3d = ucl.reshape((N, N, N))
    mid_idx = N // 2

    fig1 = go.Figure(data=go.Scatter3d(
        x=X.flatten(), y=Y.flatten(), z=Z.flatten(),
        mode='markers',
        marker=dict(
            size=5, color=xquant, colorscale='turbo',
            colorbar=dict(title='Temperature'), opacity=0.8
        ),
        text=[f"x={xv:.2f}<br>y={yv:.2f}<br>z={zv:.2f}<br>Temp={t:.2f}"
              for xv, yv, zv, t in zip(X.flatten(), Y.flatten(), Z.flatten(), xquant)],
        hoverinfo='text'
    ))
    fig1.update_layout(
        scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),
        title=f'Quantum VQA 3D Temp Field ({ansatz_name})'
    )
    fig1.show(renderer="colab")

    fig2 = go.Figure(data=go.Scatter3d(
        x=X.flatten(), y=Y.flatten(), z=Z.flatten(),
        mode='markers',
        marker=dict(
            size=5, color=ucl, colorscale='turbo',
            colorbar=dict(title='Temperature'), opacity=0.8
        ),
        text=[f"x={xv:.2f}<br>y={yv:.2f}<br>z={zv:.2f}<br>Temp={t:.2f}"
              for xv, yv, zv, t in zip(X.flatten(), Y.flatten(), Z.flatten(), ucl)],
        hoverinfo='text'
    ))
    fig2.update_layout(
        scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),
        title='Classical 3D Temperature Field'
    )
    fig2.show(renderer="colab")

    # 2D slice in teh center
    fig, axs = plt.subplots(1, 2, figsize=(10, 4))
    c1 = axs[0].imshow(uquant3d[:, :, mid_idx], cmap='plasma', origin='lower')
    axs[0].set_title(f"Quantum Center Slice z=L/2 ({ansatz_name})")
    plt.colorbar(c1, ax=axs[0])
    c2 = axs[1].imshow(ucl3d[:, :, mid_idx], cmap='plasma', origin='lower')
    axs[1].set_title("Classical Center Slice z=L/2")
    plt.colorbar(c2, ax=axs[1])
    plt.tight_layout()
    plt.show()

    print("="*70)