
import numpy as np

import qiskit as qi # 1.1.1
from qiskit.circuit import Parameter 
from qiskit.circuit import library as li, ParameterVector
from qiskit.quantum_info import  Statevector
from qiskit.primitives import Sampler
import matplotlib,random,math
from matplotlib import pyplot as plt
import scipy as sp

sampler = Sampler()
"""
Here we check the shift rule for quantum circuit, containing 
a single parametrized rotational gate  RR ={RX(xx), RY(xx) or RZ(xx)}
if we have a vector VV of probability amplitudes VV = Ansatz(xx)|0> 
generated by some Ansatz that depends on xx trough RR, then
d VV(xx)/d xx = 1/2 Ansatz(xx+pi)|0>
"""
global ans,f

def cost_func(par,*k,**kw):
    """ cost = -<f|psi> """
    global ans,ff
    ans_tmp = ans.assign_parameters(parameters=par, inplace=False)
    psi = Statevector(ans_tmp).data.real
    cost = - ff @ psi
    return cost

def drv(par,*k,**kw):
    # derivatives with shift rule
    global ans,ff
    deriv = np.zeros([ans.num_parameters], dtype=float)
    for ii in range(ans.num_parameters):
        par[ii] += np.pi
        new_s = ans.assign_parameters(par, inplace=False)
        psi_shift = Statevector(new_s).data.real
        deriv[ii] = -ff @ psi_shift
        par[ii] -= np.pi
    deriv *= 0.5
    return deriv

def hess(par,*k,**kw):
    global ans,ff
    # derivatives Hessian with shift rule
    hessian = np.zeros([ans.num_parameters,ans.num_parameters], dtype=float)
    for ii in range(ans.num_parameters):
        for jj in range(ii):
            par[ii] += np.pi
            par[jj] += np.pi
            new_s = ans.assign_parameters(par, inplace=False)
            psi_shift = Statevector(new_s).data.real
            hessian[ii,jj] = -ff @ psi_shift
            par[ii] -= np.pi
            par[jj] -= np.pi
    hessian += hessian.T
    # get diagonal part
    new_s = ans.assign_parameters(par, inplace=False)
    psi_shift = Statevector(new_s).data.real
    hessian += (ff @ psi_shift) * np.eye(ans.num_parameters)
    hessian *= 0.25
    return hessian

# qbits number
nqb = 14

# number of ansatz parameters
num_para = nqb*2


# the function we will try to fit with Anzatz
# gauss with discontinuities
def gauss(xx) :
    steps = 1
    for i in np.linspace(-1, 1, 7):
        steps *= np.sign(xx+i)
    return np.exp(-xx*xx*4)*steps

vgauss = np.vectorize(gauss)
coord = np.linspace(-1, 1, 2**nqb)

f = vgauss(coord)

f /= np.linalg.norm(f)

plt.plot( coord, f,'o-', linewidth=2.0, label='init_func')
plt.show()

# parameters vector
theta = np.empty([num_para],dtype=object)
for ii in range(num_para):
    theta[ii] = Parameter("theta_"+str(ii))

# Build some parametrized quantum circuit = Ansatz
qc = qi.QuantumCircuit(nqb)
qc.h(range(nqb))
for ii in range(nqb):
    qc.ry(theta[ii],ii)
qc.cx(nqb-1,0)
for ii in range(nqb-1):
    qc.cx(ii,ii+1)
for ii in range(nqb):
    qc.ry(theta[ii + nqb],ii)
# additional ansatz cnot
# qc.cx(nqb-1,0)
# for ii in range(nqb-1):
#     qc.cx(ii,ii+1)

print("Ansatz is created")
# assign global variables
ff = f
ans = qc

# set initial parameters
#init_para = np.arange(num_para)
init_para = np.array(4 * np.pi * np.random.random(num_para))


# Hessian test
test = np.zeros([num_para,num_para],dtype=float)
for ii in range(num_para):
    for jj in range(num_para):
        para_shift = np.zeros(num_para)
        para_shift[ii] += np.pi
        para_shift[jj] += np.pi
#        test[ii,jj] = hess(init_para,qc,f)[ii,jj] + (f @ Statevector(qc.assign_parameters(init_para + para_shift)).data.real)/4

print("TEST Hessian", np.linalg.norm(test).round(6)==0)
#print(np.round(test,3))

print("Initial value of cost : ", cost_func(init_para))
print("Initial gradient of cost : ", 2*drv(init_para))

eigenvalues, eigenvectors = np.linalg.eig(hess(init_para,qc,f))
print("Eigen Values",eigenvalues)




exit()
# for kk in range(10):
#     init_drv = drv(init_para)
#     iindex = np.argmax(np.abs(init_drv))
#     if abs(cost_func(init_para))/2. < abs(init_drv[iindex]) :
#         init_para[iindex] += np.pi
#         if cost_func(init_para) > 0 : init_para[iindex] += 2*np.pi
#     else : break
#     print("################### LOOP ",kk)
#     print("Value of cost : ", cost_func(init_para))
#     print("Gradient of cost : ", np.round(2*drv(init_para),3))
#     eigenvalues, eigenvectors = np.linalg.eig(hess(init_para,qc,f))
#     print("Eigen Values",np.round(eigenvalues,3))

stp=0 
while abs(cost_func(init_para)) < 0.9:
    stp +=1
    init_drv = drv(init_para)
    iindex = np.argmax(np.abs(init_drv))
    if abs(cost_func(init_para))/2. < abs(init_drv[iindex]) :
        init_para[iindex] += np.pi
        if cost_func(init_para) > 0 : init_para[iindex] += 2*np.pi
    for kk in range(len(init_para)):
        init_drv = drv(init_para)
        if abs(cost_func(init_para))<1e-5 : 
            init_para[kk] += np.pi 
        else : 
            init_para[kk] = 2*np.arctan(init_drv[kk]/cost_func(init_para))
        if cost_func(init_para) > 0 : init_para[kk] += 2*np.pi
        print("################### LOOP ",kk, stp)
        print("Value of cost : ", cost_func(init_para))
        print("Gradient of cost : ", np.round(2*drv(init_para),3))
        eigenvalues, eigenvectors = np.linalg.eig(hess(init_para,qc,f))
        print("Eigen Values",np.round(eigenvalues,3))
    if stp>2 : break

BC = [[-2*np.pi, 2*np.pi] for _ in range(num_para)] 
# Needs to be 2pi because Ry gates are parametrized by theta/2, 
# therefore they make complete rotation with angle 4pi.

# res = sp.optimize.minimize(cost_func, init_para, tol=1e-9, bounds=BC, \
# #                          method='L-BFGS-B',jac=drv)
#                            method='Newton-CG', jac=drv, hess=hess )
# res_opt = res.x
import nlopt

par0 = init_para
method = 'LN_NEWUOA'
print(f'Initializing optimizer via {method}, {len(par0)}param. !')
obj = nlopt.opt(nlopt.LN_NEWUOA, len(par0))
# defines which nlopt algorithm to use
obj.set_local_optimizer(nlopt.opt(nlopt.LN_PRAXIS, len(par0)))
print(f'{nlopt.LN_NEWUOA} Optimizer initialized !')
obj.set_ftol_abs(5e-14)  # absolute tolerance on result
obj.set_ftol_rel(5e-12)  # relative tolerance on result
#obj.set_initial_step()
obj.set_min_objective(cost_func)
print(f'Starting optimization via {method} !')
res_opt = obj.optimize(par0)


# print("Message :", res.message)
# print("Success :", res.success)
# print("nfev :", res.nfev)
# print("x :", res.x)
print("Quantum minimum :", cost_func(res_opt))
print("Final norm of gradient of cost : ", np.linalg.norm(drv(res_opt)).round(6))

new_s = qc.assign_parameters(res_opt, inplace=False)
psi_shift = Statevector(new_s).data.real

plt.plot( coord, psi_shift,'o-', linewidth=2.0, label='init_func')

#qc.draw(output="mpl")

plt.show()
